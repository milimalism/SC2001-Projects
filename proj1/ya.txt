This slide shows empirical time analyses of the sorting algorithms. 
That is, we measure the CPU times used by the algorithms in a real computer,
The time unit is millisecond. 
The algorithms are supposed to sort the numbers in ascending order
In the first column of data, labeled by “UP”, the input was ten thousand numbers in ascending order. 
In the column labeled with “DOWN”, the input data are ten thousand numbers in descending order.
The column between “UP” and “DOWN” columns contains CPU time for input numbers that are in random order. 
For the last column, the input are one hundred thousand numbers in random order. 


As we can see from the table:
Insertion sort is indeed very fast when the input numbers are already sorted, because that is the best case for Insertion sort. However, when the input numbers are reversely sorted, then the performance of Insertion sort is very bad. It takes much longer than all the other algorithms.We can see that the empirical observation agrees with our theory about the running time. When input numbers are in random order, as shown in the column between “UP” and “DOWN”, we can see that Insertion sort also has very poor performance. Likewise, for the larger input data with one hundred thousand numbers, Insertion sort is much slower than other algorithms. 

But for Mergesort, we can see that the performance is quite consistent. It has almost equally good performance for all the three input cases. 

The speed of Quicksort is really impressive. It is much faster than all the other algorithms in most cases, except for the best case of Insertion sort. What is nice about Quicksort is that, it is not easy to find the worst-case input for Quicksort. 

For Heapsort, it is consistently good, when compared with Insertion sort. But it has quite some overhead, which is measured by the constant multiplier in the big Oh notation. One reason is that we need to maintain the data structure of maximising heap, which will incur some overhead cost. But like Mergesort, Heapsort is quite reliable, meaning that it performs consistently well for different kinds of input data. On a whole, we can see that the empirical analyses of CPU times of the sorting algorithms agree with our theoretical analysis of the time complexity. That means our mathematical analysis of the sorting algorithms has good predictive power about their real performances. 
